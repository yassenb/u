// Generated by CoffeeScript 1.6.2
(function() {
  var compile, exec, pad, parse, renderAST, repeat, repr, tokenize, _, _ref;

  _ = require('lib/underscore');

  parse = require('src/peg-parser/u-grammar').parse;

  tokenize = require('src/lexer').tokenize;

  _ref = require('src/compiler'), compile = _ref.compile, exec = _ref.exec;

  jQuery(function($) {
    return $('#inp').focus().keypress(function(event) {
      var e, t, tokenStream, uCode;

      if (String.fromCharCode(event.which) === "\r") {
        uCode = $('#inp').val();
        if (!uCode) {
          return false;
        }
        $('#outp').text($('#outp').text() + '\n' + ((function() {
          try {
            if (/^\.t\b/.test(uCode)) {
              uCode = uCode.slice(3);
              tokenStream = tokenize(uCode);
              return "Tokens for " + (JSON.stringify(uCode)) + ":\n  type      value               startLine:startCol-endLine:endCol\n  ----      -----               ---------------------------------\n  " + (((function() {
                var _results;

                _results = [];
                while ((t = tokenStream.next()).type !== 'eof') {
                  _results.push(pad(10, t.type) + pad(20, JSON.stringify(t.value)) + t.startLine + ':' + t.startCol + '-' + t.endLine + ':' + t.endCol);
                }
                return _results;
              })()).join('\n  '));
            } else if (/^\.a\b/.test(uCode)) {
              uCode = uCode.slice(3);
              return "AST for " + (JSON.stringify(uCode)) + ":\n" + (renderAST(parse(uCode)));
            } else if (/^\.c\b/.test(uCode)) {
              uCode = uCode.slice(3);
              return "Compiled JavaScript for " + (JSON.stringify(uCode)) + ":\n" + (compile(uCode));
            } else {
              return repr(exec(uCode));
            }
          } catch (_error) {
            e = _error;
            return e.stack;
          }
        })()));
        $(window).scrollTop($(document).height());
        false;
      }
      return true;
    });
  });

  renderAST = function(node, indent) {
    var k, nodes, result, v;

    if (indent == null) {
      indent = '';
    }
    return indent + (typeof node === 'string' ? JSON.stringify(node) : node instanceof Array ? (nodes = _(node).map(function(n) {
      return renderAST(n, indent + '  ');
    }), "[\n" + (nodes.join('\n')) + "\n" + indent + "]") : (result = (function() {
      var _results;

      _results = [];
      for (k in node) {
        v = node[k];
        _results.push("" + k + ":\n" + (renderAST(v, indent + '  ')));
      }
      return _results;
    })(), result.join('\n' + indent)));
  };

  repr = function(x) {
    var h, y;

    if (x instanceof Array) {
      return "[" + (((function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = x.length; _i < _len; _i++) {
          y = x[_i];
          _results.push(repr(y));
        }
        return _results;
      })()).join(';')) + "]";
    } else if (typeof x === 'number') {
      if (x === Infinity) {
        return '$pinf';
      } else if (x === -Infinity) {
        return '$ninf';
      } else {
        return '' + x;
      }
    } else if (typeof x === 'boolean') {
      return '$' + 'ft'[+x];
    } else if (typeof x === 'function') {
      return '@{...}';
    } else if (typeof x === 'string') {
      h = {
        '\n': "'n",
        '\t': "'t",
        ')': "')",
        "'": "''"
      };
      return "'(" + (x.replace(/[\n\t\)']/g, function(x) {
        return h[x];
      })) + ")";
    } else if (x === null) {
      return '$';
    } else {
      return '' + x;
    }
  };

  pad = function(width, s) {
    return s + repeat(' ', Math.max(0, width - s.length));
  };

  repeat = function(s, n) {
    return Array(n + 1).join(s);
  };

}).call(this);
