// Generated by CoffeeScript 1.6.2
(function() {
  var lexer,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  lexer = require('./lexer');

  this.parse = function(code, opts) {
    var consume, demand, parseExpr, parseLocal, parseProgram, parseValue, parserError, result, token, tokenStream;

    if (opts == null) {
      opts = {};
    }
    tokenStream = lexer.tokenize(code);
    token = tokenStream.next();
    consume = function(tts) {
      var _ref;

      if (_ref = token.type, __indexOf.call(tts, _ref) >= 0) {
        return token = tokenStream.next();
      }
    };
    demand = function(tt) {
      if (token.type !== tt) {
        parserError("Expected token of type '" + tt + "' but got '" + token.type + "'");
      }
      token = tokenStream.next();
    };
    parserError = function(message) {
      throw Error("Parser error: " + message + " at " + token.startLine + ":" + token.startCol, {
        file: opts.file,
        line: token.startLine,
        col: token.startCol,
        code: code
      });
    };
    parseProgram = function() {
      return parseExpr();
    };
    parseExpr = function() {
      var r;

      r = ['expression', parseValue()].concat((function() {
        var _ref, _results;

        _results = [];
        while ((_ref = token.type) !== ')' && _ref !== ']' && _ref !== '}' && _ref !== ';' && _ref !== '==' && _ref !== '::' && _ref !== '++' && _ref !== 'eof') {
          _results.push(parseValue());
        }
        return _results;
      })());
      if (r.length === 2) {
        return r[1];
      } else {
        return r;
      }
    };
    parseValue = function() {
      var e, elseClause, ifThenClauses, local, r, t;

      t = token;
      if (consume(['number', 'string', 'name', '_'])) {
        return [t.type, t.value];
      } else if (consume(['('])) {
        r = parseExpr();
        demand(')');
        return r;
      } else if (consume(['['])) {
        r = ['sequence'];
        if (token.type !== ']') {
          r.push(parseValue());
          while (consume([';'])) {
            r.push(parseValue());
          }
        }
        demand(']');
        return r;
      } else if (consume(['{'])) {
        r = ['parametric', parseExpr(), parseLocal()];
        demand('}');
        return r;
      } else if (consume(['?{'])) {
        ifThenClauses = [];
        elseClause = null;
        while (true) {
          e = parseExpr();
          if (consume(['::'])) {
            ifThenClauses.push(['::', e, parseExpr()]);
          } else {
            elseClause = e;
            break;
          }
          if (!consume([';'])) {
            break;
          }
        }
        local = token.type === '++' ? parseLocal() : null;
        demand('}');
        return ['conditional'].concat(ifThenClauses, [elseClause], [local]);
      } else if (consume(['@{'])) {
        throw Error('Not implemented');
      } else {
        return parserError("Expected value but found " + t.type);
      }
    };
    parseLocal = function() {
      throw Error('Not implemented: parseLocal()');
    };
    result = parseProgram();
    demand('eof');
    return result;
  };

}).call(this);
